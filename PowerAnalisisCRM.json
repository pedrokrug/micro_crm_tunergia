{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "power-analysis-crm",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -32,
        -772
      ],
      "id": "ae1df316-cf95-44dd-bf3b-09fa9c929706",
      "name": "Analisis de Potencia",
      "webhookId": "59200adf-d6df-4dd2-b319-5ab57d2e5052"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "cd9693c7-ebd3-4c5b-aed3-52fc552cadae",
              "leftValue": "={{ $json.body.has_bill }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        192,
        -772
      ],
      "id": "0024fb26-2508-43bd-a610-1bc76df2ef8d",
      "name": "Has Bill?"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// CONVERT TO PDF - Extract file data from request\n// ============================================\n\nconst webhookData = $input.first().json;\nconst body = webhookData.body || webhookData;\n\nconsole.log('Convert to PDF - Processing bill upload');\nconsole.log('Body keys:', Object.keys(body));\n\n// Extract file data - could be base64 or binary\nlet fileData = null;\nlet fileName = 'uploaded_bill.pdf';\n\n// Check for base64 file data\nif (body.file_data) {\n  fileData = body.file_data;\n  fileName = body.file_name || fileName;\n  console.log('Found base64 file data');\n} else if (body.file) {\n  // Handle FormData file upload\n  fileData = body.file;\n  fileName = body.file.name || fileName;\n  console.log('Found file object');\n}\n\n// Pass through all the data needed for extraction\nreturn {\n  json: {\n    file_data: fileData,\n    file_name: fileName,\n    user_name: body.user_name || 'Tunet',\n    user_email: body.user_email || 'info@tunergia.es',\n    user_phone: body.user_phone || '',\n    // No manual prices - we'll extract from bill\n    precios_potencia_manual: null\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        -932
      ],
      "id": "convert-to-pdf-node",
      "name": "Convert to PDF"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PREPARE MANUAL INPUT DATA\n// ============================================\n// When user doesn't have a bill, use CUPS and manual prices\n\nconst webhookData = $input.first().json;\nconst body = webhookData.body || webhookData;\n\nconsole.log('Prepare Manual Input - Using CUPS and manual prices');\nconsole.log('CUPS:', body.cups);\n\n// Get manual prices from request, or use BOE defaults\nconst preciosPotencia = {\n  P1: body.precio_p1 || 0.053858904,\n  P2: body.precio_p2 || 0.028086712,\n  P3: body.precio_p3 || 0.011678192,\n  P4: body.precio_p4 || 0.010086438,\n  P5: body.precio_p5 || 0.006378548,\n  P6: body.precio_p6 || 0.003716137\n};\n\nconsole.log('Manual Power Prices:', preciosPotencia);\n\n// Create output structure matching what Prepare Power Analysis Data expects\nreturn {\n  json: {\n    // Simulated bill data with just CUPS\n    cups: body.cups,\n    tarifa_acceso: body.tarifa || '3.0TD', // Default to 3.0TD if not specified\n    // User info\n    user_name: body.user_name || 'Tunet',\n    user_email: body.user_email || 'info@tunergia.es',\n    user_phone: body.user_phone || '',\n    // Manual prices flag and values\n    precios_potencia_manual: preciosPotencia,\n    is_manual_input: true\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        -612
      ],
      "id": "prepare-manual-input-node",
      "name": "Prepare Manual Input"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-haiku-4-5-20251001",
          "mode": "list",
          "cachedResultName": "Claude Haiku 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        752,
        -708
      ],
      "id": "4da71f48-fffd-4335-935b-83ea25ecd423",
      "name": "Anthropic Chat Model1",
      "credentials": {
        "anthropicApi": {
          "id": "IorIZbF3bkuc6oRn",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "text": "={{ $json.text }}",
        "attributes": {
          "attributes": [
            {
              "name": "cups",
              "description": "CUPS number, starts with ES"
            },
            {
              "name": "tarifa_acceso",
              "description": "Tarifa de Acceso (2.0TD, 3.0TD, or 6.1TD)"
            },
            {
              "name": "power_price_p1",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P1 in ‚Ç¨/kW¬∑d√≠a (look for 'T√©rmino de potencia' or 'Precio potencia')"
            },
            {
              "name": "power_price_p2",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P2 in ‚Ç¨/kW¬∑d√≠a"
            },
            {
              "name": "power_price_p3",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P3 in ‚Ç¨/kW¬∑d√≠a (only for 3.0TD and 6.1TD)"
            },
            {
              "name": "power_price_p4",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P4 in ‚Ç¨/kW¬∑d√≠a (only for 3.0TD and 6.1TD)"
            },
            {
              "name": "power_price_p5",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P5 in ‚Ç¨/kW¬∑d√≠a (only for 3.0TD and 6.1TD)"
            },
            {
              "name": "power_price_p6",
              "type": "number",
              "description": "Precio T√©rmino de Potencia P6 in ‚Ç¨/kW¬∑d√≠a (only for 3.0TD and 6.1TD)"
            }
          ]
        },
        "options": {
          "systemPromptTemplate": "You are an expert extraction algorithm for Spanish Electricity Bills. Your primary goal is to extract the CUPS, tarifa_acceso, and the POWER PRICES (Precio T√©rmino de Potencia) for each period. Look for sections labeled 'T√©rmino de potencia', 'Precio potencia', or similar. The power prices are typically in ‚Ç¨/kW¬∑d√≠a format. For 2.0TD tariffs, extract P1-P2. For 3.0TD and 6.1TD, extract P1-P6. If a price appears as a single value, note it for P1. Be precise with decimal values."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        640,
        -932
      ],
      "id": "f35e41cf-2757-4b03-87e1-6e7004eb1c9b",
      "name": "Extract Bill Data"
    },
    {
      "parameters": {
        "jsCode": "const claudeResponse = $input.first().json;\nconst convertData = $('Convert to PDF').first().json;\n\nconsole.log('Normalize Bill Extraction - Processing Claude response');\n\n// Extract the content from Claude's response\nlet extractedData;\n\ntry {\n  // Handle Information Extractor output format\n  if (claudeResponse.output) {\n    extractedData = claudeResponse.output;\n  } else if (claudeResponse.content && Array.isArray(claudeResponse.content)) {\n    // Direct Claude API response\n    let jsonText = claudeResponse.content[0].text;\n    jsonText = jsonText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n    extractedData = JSON.parse(jsonText);\n  } else {\n    extractedData = claudeResponse;\n  }\n  \n  console.log('Extracted data:', extractedData);\n  \n} catch (error) {\n  console.error('Error parsing extraction response:', error);\n  throw new Error(`Failed to parse bill extraction: ${error.message}`);\n}\n\n// Build output structure for Prepare Power Analysis Data\nreturn {\n  json: {\n    cups: extractedData.cups || extractedData.CUPS,\n    tarifa_acceso: extractedData.tarifa_acceso,\n    // Power prices from bill\n    power_price_p1: extractedData.power_price_p1 || 0,\n    power_price_p2: extractedData.power_price_p2 || 0,\n    power_price_p3: extractedData.power_price_p3 || 0,\n    power_price_p4: extractedData.power_price_p4 || 0,\n    power_price_p5: extractedData.power_price_p5 || 0,\n    power_price_p6: extractedData.power_price_p6 || 0,\n    // User info from Convert to PDF\n    user_name: convertData.user_name,\n    user_email: convertData.user_email,\n    user_phone: convertData.user_phone,\n    // No manual prices - using extracted\n    precios_potencia_manual: null,\n    is_manual_input: false\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        -932
      ],
      "id": "1d7bb9b6-43a4-4ee9-80aa-087f5359bf87",
      "name": "Normalize Bill Extraction"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PREPARE POWER ANALYSIS DATA\n// ============================================\n// Unified handler for both manual input and bill extraction\n\nconst inputData = $input.first().json;\n\nconsole.log('Prepare Power Analysis Data');\nconsole.log('Input source:', inputData.is_manual_input ? 'MANUAL' : 'BILL');\n\n// Determine power prices source\nlet preciosPotencia = {};\n\nif (inputData.precios_potencia_manual) {\n  // Manual input - use provided prices\n  preciosPotencia = inputData.precios_potencia_manual;\n  console.log('Using MANUAL power prices:', preciosPotencia);\n} else {\n  // Bill extraction - use extracted prices\n  preciosPotencia = {\n    P1: inputData.power_price_p1 || 0.053858904,\n    P2: inputData.power_price_p2 || 0.028086712,\n    P3: inputData.power_price_p3 || 0.011678192,\n    P4: inputData.power_price_p4 || 0.010086438,\n    P5: inputData.power_price_p5 || 0.006378548,\n    P6: inputData.power_price_p6 || 0.003716137\n  };\n  console.log('Using BILL power prices:', preciosPotencia);\n}\n\nconst analysisData = {\n  cups: inputData.cups,\n  tarifa: inputData.tarifa_acceso || inputData.tarifa || '3.0TD',\n  precios_potencia: preciosPotencia,\n  user_name: inputData.user_name || 'Tunet',\n  user_email: inputData.user_email || 'info@tunergia.es',\n  user_phone: inputData.user_phone || '',\n  is_manual_input: inputData.is_manual_input || false\n};\n\nconsole.log('Power Analysis Data Prepared:', {\n  cups: analysisData.cups,\n  tarifa: analysisData.tarifa,\n  prices_source: inputData.precios_potencia_manual ? 'MANUAL' : 'BILL/DEFAULT'\n});\n\nreturn { json: analysisData };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        -772
      ],
      "id": "6ee078f7-5ad6-4bd4-82fc-bfe083d6ccac",
      "name": "Prepare Power Analysis Data"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://plenaenergia-tradeenergy.nemon2ib.com/api",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "token",
              "value": "57a9d001ca37849fd406e051463e0e0edf5302b9"
            },
            {
              "name": "module",
              "value": "Sips"
            },
            {
              "name": "class",
              "value": "SipsData"
            },
            {
              "name": "action",
              "value": "getData"
            },
            {
              "name": "data",
              "value": "={\"typeenergy\":\"elec\",\"request\":\"detail\", \"cups\":\"{{ $json.cups }}\"}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1312,
        -772
      ],
      "id": "82f2bd05-1444-487d-a001-82df5a1cf9f1",
      "name": "Fetch SIPS Data for Power"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// COMBINE DATA FOR ANALYSIS\n// ============================================\n// Combines: prepared analysis data + SIPS response\n\nconst preparedData = $('Prepare Power Analysis Data').first().json;\nconst sipsResponse = $input.first().json;\n\nconsole.log('Combining data for analysis');\nconsole.log('CUPS:', preparedData.cups);\nconsole.log('Tarifa:', preparedData.tarifa);\nconsole.log('SIPS data received:', !!sipsResponse.data);\n\nreturn {\n  json: {\n    // From Prepare Power Analysis Data\n    cups: preparedData.cups,\n    tarifa: preparedData.tarifa,\n    precios_potencia: preparedData.precios_potencia,\n    user_name: preparedData.user_name,\n    user_email: preparedData.user_email,\n    is_manual_input: preparedData.is_manual_input,\n    \n    // From SIPS API\n    sips_data: sipsResponse.data || sipsResponse\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1536,
        -772
      ],
      "id": "1a1c5839-a56e-49b0-af2e-23561224a0b3",
      "name": "Combine Data for Analysis"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// BOE 2025 EXCESS POWER PRICES (‚Ç¨/kW¬∑d√≠a)\n// ============================================================================\nconst EXCESS_POWER_PRICES = {\n    '2.0TD': {\n        P1: 2.953979, P2: 0.056891,\n        P3: 0, P4: 0, P5: 0, P6: 0\n    },\n    '3.0TD': {\n        P1: 3.361213, P2: 1.776545, P3: 0.563477,\n        P4: 0.430844, P5: 0.121880, P6: 0.121880\n    },\n    '6.1TD': {\n        P1: 3.332942, P2: 1.762138, P3: 0.661311,\n        P4: 0.465989, P5: 0.009852, P6: 0.008771\n    },\n    '6.2TD': {\n        P1: 3.292963, P2: 1.867567, P3: 0.491658,\n        P4: 0.299575, P5: 0.011745, P6: 0.010432\n    },\n    '6.3TD': {\n        P1: 3.099043, P2: 1.867297, P3: 0.608334,\n        P4: 0.396461, P5: 0.013018, P6: 0.011460\n    },\n    '6.4TD': {\n        P1: 2.732620, P2: 1.633705, P3: 0.396742,\n        P4: 0.275775, P5: 0.008201, P6: 0.005465\n    }\n};\n\nfunction getLast12MonthsPeriod(lecturas) {\n    if (!lecturas || lecturas.length === 0) {\n        return null;\n    }\n    \n    let mostRecent = null;\n    for (const lectura of lecturas) {\n        const fechaStr = lectura.FLectM1 || '';\n        if (fechaStr) {\n            try {\n                const fecha = new Date(fechaStr.replace('Z', ''));\n                if (mostRecent === null || fecha > mostRecent) {\n                    mostRecent = fecha;\n                }\n            } catch (e) {\n                continue;\n            }\n        }\n    }\n    \n    if (!mostRecent) {\n        return null;\n    }\n    \n    let startYear = mostRecent.getFullYear();\n    let startMonth = mostRecent.getMonth() - 10; // JS months are 0-indexed\n    \n    if (startMonth < 0) {\n        startMonth += 12;\n        startYear -= 1;\n    }\n    \n    const startDate = new Date(startYear, startMonth, 1);\n    \n    const monthNames = [\n        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',\n        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'\n    ];\n    \n    return {\n        startDate: startDate,\n        endDate: mostRecent,\n        periodText: `${monthNames[startDate.getMonth()]} ${startDate.getFullYear()} - ${monthNames[mostRecent.getMonth()]} ${mostRecent.getFullYear()}`\n    };\n}\n\nfunction aggregateReadingsByMonth(lecturas) {\n    const monthlyReadings = {};\n    \n    for (const lectura of lecturas) {\n        const fechaStr = lectura.FLectM1 || '';\n        if (!fechaStr) continue;\n        \n        try {\n            const fecha = new Date(fechaStr.replace('Z', ''));\n            const year = fecha.getFullYear();\n            const month = String(fecha.getMonth() + 1).padStart(2, '0');\n            const monthKey = `${year}-${month}`;\n            \n            if (!monthlyReadings[monthKey]) {\n                monthlyReadings[monthKey] = {\n                    CUPS: lectura.CUPS || '',\n                    FLectM1: fechaStr,\n                    Tarifa: lectura.Tarifa || '',\n                    CPotP1M1: 0, CPotP2M1: 0, CPotP3M1: 0,\n                    CPotP4M1: 0, CPotP5M1: 0, CPotP6M1: 0\n                };\n            }\n            \n            for (const period of ['P1', 'P2', 'P3', 'P4', 'P5', 'P6']) {\n                const key = `CPot${period}M1`;\n                monthlyReadings[monthKey][key] = Math.max(\n                    monthlyReadings[monthKey][key],\n                    lectura[key] || 0\n                );\n            }\n        } catch (e) {\n            continue;\n        }\n    }\n    \n    return Object.keys(monthlyReadings)\n        .sort()\n        .reverse()\n        .map(k => monthlyReadings[k]);\n}\n\nfunction getActivePeriods(tarifa) {\n    if (tarifa === '2.0TD') {\n        return ['P1', 'P2'];\n    } else {\n        return ['P1', 'P2', 'P3', 'P4', 'P5', 'P6'];\n    }\n}\n\nfunction determineMeasurementPointType(potContratadaDict) {\n    const maxContractedPower = Math.max(...Object.values(potContratadaDict));\n    \n    if (maxContractedPower <= 15) {\n        return 5;\n    } else if (maxContractedPower <= 50) {\n        return 4;\n    } else if (maxContractedPower <= 450) {\n        return 3;\n    } else if (maxContractedPower <= 50000) {\n        return 2;\n    } else {\n        return 1;\n    }\n}\n\nfunction calculatePenaltyBoe2025(potenciaRegistrada, potenciaContratada, tarifa, periodo, \n                                  measurementType, daysInMonth = 30) {\n    if (potenciaRegistrada <= potenciaContratada) {\n        return { hasPenalty: false, penaltyEuros: 0.0, notes: \"Dentro de lo contratado\" };\n    }\n    \n    const excessPrices = EXCESS_POWER_PRICES[tarifa] || {};\n    const tep = excessPrices[periodo] || 0;\n    \n    if (tep === 0) {\n        return { hasPenalty: false, penaltyEuros: 0.0, notes: \"No hay precio de exceso definido\" };\n    }\n    \n    const excesoKw = potenciaRegistrada - potenciaContratada;\n    \n    // TYPE 4 & 5 CALCULATION (‚â§50 kW) - 105% RULE\n    if (measurementType === 4 || measurementType === 5) {\n        const threshold105 = 1.05 * potenciaContratada;\n        \n        if (potenciaRegistrada <= threshold105) {\n            return { \n                hasPenalty: false, \n                penaltyEuros: 0.0, \n                notes: `Dentro del margen del 105% (${threshold105.toFixed(2)} kW)` \n            };\n        }\n        \n        // Apply formula: PF = PR + 2√ó(PR - 1.05√óPC)\n        const excessOver105 = potenciaRegistrada - threshold105;\n        const potenciaFacturada = potenciaRegistrada + 2 * excessOver105;\n        \n        // Penalty is the difference between billed power and contracted power\n        const excessToBill = potenciaFacturada - potenciaContratada;\n        const penaltyEuros = excessToBill * tep * daysInMonth;\n        \n        const notes = `Exceso > 105%. Penalizaci√≥n: ${excessToBill.toFixed(2)} kW √ó ${tep.toFixed(6)} ‚Ç¨/kW¬∑d√≠a √ó ${daysInMonth} d√≠as`;\n        return { hasPenalty: true, penaltyEuros, notes };\n    }\n    \n    // TYPE 1, 2 & 3 CALCULATION (>50 kW) - QUADRATIC\n    else {\n        const penaltyEuros = tep * (excesoKw ** 2);\n        const notes = `Penalizaci√≥n cuadr√°tica: (${excesoKw.toFixed(2)} kW)¬≤ √ó ${tep.toFixed(6)} ‚Ç¨/kW`;\n        return { hasPenalty: true, penaltyEuros, notes };\n    }\n}\n\nfunction enforceAscendingPower(potSugeridaDict, activePeriods, tarifa = '') {\n    const adjusted = {};\n    let previousValue = null;\n    \n    for (const periodo of activePeriods) {\n        const currentValue = potSugeridaDict[periodo] || 0;\n        \n        if (previousValue === null) {\n            adjusted[periodo] = currentValue;\n        } else {\n            adjusted[periodo] = Math.max(currentValue, previousValue);\n        }\n        \n        previousValue = adjusted[periodo];\n    }\n    \n    // Special rule for 3.0TD: P6 must be at least 15.10 kW\n    if (tarifa === '3.0TD' && adjusted.P6 !== undefined) {\n        if (adjusted.P6 < 15.10) {\n            adjusted.P6 = 15.10;\n            // Propagate backwards\n            for (let i = activePeriods.length - 2; i >= 0; i--) {\n                const periodo = activePeriods[i];\n                const nextPeriodo = activePeriods[i + 1];\n                if (adjusted[periodo] > adjusted[nextPeriodo]) {\n                    adjusted[periodo] = adjusted[nextPeriodo];\n                }\n            }\n        }\n    }\n    \n    // Special rule for 2.0TD: Maximum 15 kW cap\n    if (tarifa === '2.0TD') {\n        for (const periodo of activePeriods) {\n            if (adjusted[periodo] > 15.0) {\n                adjusted[periodo] = 15.0;\n            }\n        }\n    }\n    \n    return adjusted;\n}\n\nfunction getMonthName(monthStr) {\n    const months = {\n        '01': 'Enero', '02': 'Febrero', '03': 'Marzo', '04': 'Abril',\n        '05': 'Mayo', '06': 'Junio', '07': 'Julio', '08': 'Agosto',\n        '09': 'Septiembre', '10': 'Octubre', '11': 'Noviembre', '12': 'Diciembre'\n    };\n    try {\n        return months[monthStr.split('-')[1]];\n    } catch (e) {\n        return monthStr;\n    }\n}\n\nfunction analyzeCupsPower(apiResponse, preciosTerminoPotencia) {\n    const results = [];\n    const parsedData = apiResponse.parsedData || apiResponse;\n    const suministros = parsedData.suministros || [];\n    const lecturas = parsedData.lecturas || [];\n    \n    for (const suministro of suministros) {\n        const cups = suministro.CUPS || '';\n        const tarifa = suministro.Tarifa || '';\n        \n        const activePeriods = getActivePeriods(tarifa);\n        const cupsLecturas = lecturas.filter(l => l.CUPS === cups);\n        \n        const analysisPeriod = getLast12MonthsPeriod(cupsLecturas);\n        if (analysisPeriod === null) {\n            continue;\n        }\n        \n        const { startDate, endDate, periodText: analysisPeriodText } = analysisPeriod;\n        \n        // Filter by date range\n        const yearLecturas = [];\n        for (const lectura of cupsLecturas) {\n            const fechaStr = lectura.FLectM1 || '';\n            if (fechaStr) {\n                try {\n                    const fecha = new Date(fechaStr.replace('Z', ''));\n                    if (fecha >= startDate && fecha <= endDate) {\n                        yearLecturas.push(lectura);\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        \n        if (yearLecturas.length === 0) {\n            continue;\n        }\n        \n        let aggregatedLecturas = aggregateReadingsByMonth(yearLecturas);\n        if (aggregatedLecturas.length > 12) {\n            aggregatedLecturas = aggregatedLecturas.slice(0, 12);\n        }\n        \n        const potContratada = {\n            P1: suministro.Pot_Cont_P1 || 0,\n            P2: suministro.Pot_Cont_P2 || 0,\n            P3: suministro.Pot_Cont_P3 || 0,\n            P4: suministro.Pot_Cont_P4 || 0,\n            P5: suministro.Pot_Cont_P5 || 0,\n            P6: suministro.Pot_Cont_P6 || 0,\n        };\n        \n        const measurementType = determineMeasurementPointType(potContratada);\n        const maxContracted = Math.max(...Object.values(potContratada));\n        \n        // Calculate average demand for suggested power\n        const potSumaGlobal = {};\n        const potCountGlobal = {};\n        \n        for (const periodo of activePeriods) {\n            let suma = 0;\n            let count = 0;\n            for (const lectura of aggregatedLecturas) {\n                const demand = lectura[`CPot${periodo}M1`] || 0;\n                if (demand > 0) {\n                    suma += demand;\n                    count += 1;\n                }\n            }\n            potSumaGlobal[periodo] = suma;\n            potCountGlobal[periodo] = count;\n        }\n        \n        const potSugeridaInicial = {};\n        for (const periodo of activePeriods) {\n            const count = potCountGlobal[periodo] || 0;\n            if (count > 0) {\n                const promedio = potSumaGlobal[periodo] / count;\n                potSugeridaInicial[periodo] = Math.round((promedio + 0.01) * 100) / 100;\n            } else {\n                potSugeridaInicial[periodo] = 0;\n            }\n        }\n        \n        const potSugeridaFinal = enforceAscendingPower(potSugeridaInicial, activePeriods, tarifa);\n        \n        // Calculate maximum demand for each period\n        const potMaximaGlobal = {};\n        for (const periodo of activePeriods) {\n            let maxDemand = 0;\n            for (const lectura of aggregatedLecturas) {\n                const demand = lectura[`CPot${periodo}M1`] || 0;\n                maxDemand = Math.max(maxDemand, demand);\n            }\n            potMaximaGlobal[periodo] = maxDemand;\n        }\n        \n        // ====================================================================\n        // CURRENT SITUATION ANALYSIS\n        // ====================================================================\n        const monthlyResults = [];\n        let totalPenaltyAnnualCurrent = 0;\n        let costePotenciaFijaActualAnual = 0;\n        \n        for (const lectura of aggregatedLecturas) {\n            const fechaLectura = lectura.FLectM1 || '';\n            const monthKey = fechaLectura.substring(0, 7);\n            const monthName = getMonthName(monthKey);\n            \n            const potMaximaMes = {\n                P1: lectura.CPotP1M1 || 0,\n                P2: lectura.CPotP2M1 || 0,\n                P3: lectura.CPotP3M1 || 0,\n                P4: lectura.CPotP4M1 || 0,\n                P5: lectura.CPotP5M1 || 0,\n                P6: lectura.CPotP6M1 || 0,\n            };\n            \n            const monthData = {\n                Mes: monthName,\n                Fecha: monthKey,\n            };\n            \n            let costeMesPenalizacion = 0;\n            let costeMesPotenciaFija = 0;\n            \n            for (const periodo of ['P1', 'P2', 'P3', 'P4', 'P5', 'P6']) {\n                const contratada = potContratada[periodo] || 0;\n                const maximaMes = potMaximaMes[periodo] || 0;\n                const precio = preciosTerminoPotencia[periodo] || 0.053858904;\n                \n                const isActive = activePeriods.includes(periodo);\n                \n                if (!isActive) {\n                    monthData[`${periodo}_Activo`] = 'NO';\n                    monthData[`${periodo}_Contratada`] = 0;\n                    monthData[`${periodo}_Maxima`] = 0;\n                    monthData[`${periodo}_Exceso`] = 0;\n                    monthData[`${periodo}_Tiene_Penalizacion`] = 'NO';\n                    monthData[`${periodo}_Penalizacion_Euros`] = 0;\n                    continue;\n                }\n                \n                monthData[`${periodo}_Activo`] = 'SI';\n                monthData[`${periodo}_Contratada`] = Math.round(contratada * 1000) / 1000;\n                monthData[`${periodo}_Maxima`] = Math.round(maximaMes * 1000) / 1000;\n                \n                // Calculate penalty\n                const { hasPenalty, penaltyEuros, notes: penaltyNotes } = calculatePenaltyBoe2025(\n                    maximaMes, contratada, tarifa, periodo, measurementType, 30\n                );\n                \n                const exceso = Math.max(0, maximaMes - contratada);\n                \n                monthData[`${periodo}_Exceso`] = Math.round(exceso * 1000) / 1000;\n                monthData[`${periodo}_Tiene_Penalizacion`] = hasPenalty ? 'SI' : 'NO';\n                monthData[`${periodo}_Penalizacion_Euros`] = Math.round(penaltyEuros * 100) / 100;\n                monthData[`${periodo}_Notas_Penalizacion`] = penaltyNotes;\n                \n                // Fixed power cost\n                const costePotenciaPeriodo = contratada * precio * 30;\n                costeMesPotenciaFija += costePotenciaPeriodo;\n                \n                if (hasPenalty) {\n                    costeMesPenalizacion += penaltyEuros;\n                }\n            }\n            \n            monthData.Coste_Mes_Potencia_Fija = Math.round(costeMesPotenciaFija * 100) / 100;\n            monthData.Coste_Mes_Penalizacion = Math.round(costeMesPenalizacion * 100) / 100;\n            \n            totalPenaltyAnnualCurrent += costeMesPenalizacion;\n            costePotenciaFijaActualAnual += costeMesPotenciaFija;\n            \n            monthlyResults.push(monthData);\n        }\n        \n        // ====================================================================\n        // PROPOSED SITUATION ANALYSIS\n        // ====================================================================\n        let totalPenaltyAnnualSuggested = 0;\n        let costePotenciaFijaSugeridaAnual = 0;\n        \n        for (const lectura of aggregatedLecturas) {\n            const potMaximaMes = {\n                P1: lectura.CPotP1M1 || 0,\n                P2: lectura.CPotP2M1 || 0,\n                P3: lectura.CPotP3M1 || 0,\n                P4: lectura.CPotP4M1 || 0,\n                P5: lectura.CPotP5M1 || 0,\n                P6: lectura.CPotP6M1 || 0,\n            };\n            \n            for (const periodo of activePeriods) {\n                const sugerida = potSugeridaFinal[periodo] || 0;\n                const maximaMes = potMaximaMes[periodo] || 0;\n                const precio = preciosTerminoPotencia[periodo] || 0.053858904;\n                \n                // Fixed power cost with suggested power\n                const costePotenciaSuggested = sugerida * precio * 30;\n                costePotenciaFijaSugeridaAnual += costePotenciaSuggested;\n                \n                // Calculate penalty with suggested power\n                const { hasPenalty: hasPenaltySuggested, penaltyEuros: penaltyEurosSuggested } = \n                    calculatePenaltyBoe2025(maximaMes, sugerida, tarifa, periodo, measurementType, 30);\n                \n                if (hasPenaltySuggested) {\n                    totalPenaltyAnnualSuggested += penaltyEurosSuggested;\n                }\n            }\n        }\n        \n        // ====================================================================\n        // CREATE SUMMARY RESULT\n        // ====================================================================\n        const costeActualTotalAnual = costePotenciaFijaActualAnual + totalPenaltyAnnualCurrent;\n        const costeSugeridoTotalAnual = costePotenciaFijaSugeridaAnual + totalPenaltyAnnualSuggested;\n        const ahorroAnual = costeActualTotalAnual - costeSugeridoTotalAnual;\n        \n        const summaryData = {\n            CUPS: cups,\n            Periodo_Analisis: analysisPeriodText,\n            Tarifa: tarifa,\n            Tipo_Medida: measurementType,\n            Potencia_Contratada_Maxima: Math.round(maxContracted * 1000) / 1000,\n            Tipo_Cliente: tarifa === '2.0TD' ? 'Domestico' : 'Empresa/Industrial',\n            \n            // Financial data\n            Coste_Potencia_Fija_Actual_Anual: Math.round(costePotenciaFijaActualAnual * 100) / 100,\n            Total_Penalizaciones_Anual: Math.round(totalPenaltyAnnualCurrent * 100) / 100,\n            Coste_Actual_Anual: Math.round(costeActualTotalAnual * 100) / 100,\n            \n            Coste_Potencia_Fija_Sugerida_Anual: Math.round(costePotenciaFijaSugeridaAnual * 100) / 100,\n            Total_Penalizaciones_Sugerido_Anual: Math.round(totalPenaltyAnnualSuggested * 100) / 100,\n            Coste_Total_Sugerido_Anual: Math.round(costeSugeridoTotalAnual * 100) / 100,\n            \n            Ahorro_Anual: Math.round(ahorroAnual * 100) / 100,\n            Ahorro_Mensual: Math.round((ahorroAnual / 12) * 100) / 100,\n        };\n        \n        // Add period details\n        const periodosConExceso = [];\n        const periodosInfrautilizados = [];\n        \n        for (const periodo of ['P1', 'P2', 'P3', 'P4', 'P5', 'P6']) {\n            const isActive = activePeriods.includes(periodo);\n            const contratada = potContratada[periodo] || 0;\n            const maximaGlobal = potMaximaGlobal[periodo] || 0;\n            const sugerida = potSugeridaFinal[periodo] || 0;\n            \n            summaryData[`${periodo}_Activo`] = isActive ? 'SI' : 'NO';\n            summaryData[`${periodo}_Contratada`] = Math.round(contratada * 1000) / 1000;\n            summaryData[`${periodo}_Maxima_Global`] = Math.round(maximaGlobal * 1000) / 1000;\n            summaryData[`${periodo}_Sugerida`] = Math.round(sugerida * 1000) / 1000;\n            \n            if (isActive) {\n                // Check months with penalty\n                const mesesConPenalizacionPeriodo = monthlyResults.filter(\n                    m => m[`${periodo}_Tiene_Penalizacion`] === 'SI'\n                ).length;\n                summaryData[`${periodo}_Meses_Con_Penalizacion`] = mesesConPenalizacionPeriodo;\n                \n                // Sum total penalties for this period\n                const penalizacionPeriodoAnual = monthlyResults.reduce(\n                    (sum, m) => sum + (m[`${periodo}_Penalizacion_Euros`] || 0), 0\n                );\n                summaryData[`${periodo}_Penalizacion_Anual`] = Math.round(penalizacionPeriodoAnual * 100) / 100;\n                \n                const utilizacion = contratada > 0 ? (maximaGlobal / contratada * 100) : 0;\n                summaryData[`${periodo}_Utilizacion_Pct`] = Math.round(utilizacion * 100) / 100;\n                \n                // Determine status\n                if (mesesConPenalizacionPeriodo > 0) {\n                    periodosConExceso.push(periodo);\n                    summaryData[`${periodo}_Estado`] = 'AUMENTAR';\n                } else if (utilizacion < 70 && contratada > 0 && maximaGlobal > 0) {\n                    periodosInfrautilizados.push(periodo);\n                    summaryData[`${periodo}_Estado`] = 'REDUCIR';\n                } else if (maximaGlobal === 0 && contratada > 0) {\n                    summaryData[`${periodo}_Estado`] = 'ELIMINAR';\n                } else {\n                    summaryData[`${periodo}_Estado`] = 'OPTIMO';\n                }\n            } else {\n                summaryData[`${periodo}_Meses_Con_Penalizacion`] = 0;\n                summaryData[`${periodo}_Penalizacion_Anual`] = 0;\n                summaryData[`${periodo}_Utilizacion_Pct`] = 0;\n                summaryData[`${periodo}_Estado`] = 'NO_APLICA';\n            }\n        }\n        \n        // General recommendation\n        if (periodosConExceso.length > 0) {\n            summaryData.Recomendacion_General = `üî¥ URGENTE - Penalizaciones en ${periodosConExceso.join(', ')}`;\n        } else if (periodosInfrautilizados.length > 0) {\n            summaryData.Recomendacion_General = `üìâ OPTIMIZAR - Infrautilizado en ${periodosInfrautilizados.join(', ')}`;\n        } else {\n            summaryData.Recomendacion_General = \"‚úÖ √ìPTIMO - Potencia bien ajustada\";\n        }\n        \n        // Add monthly breakdown as JSON string\n        summaryData.Detalle_Mensual = JSON.stringify(monthlyResults);\n        \n        results.push(summaryData);\n    }\n    \n    return results;\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\nconsole.log(\"=\".repeat(50));\nconsole.log(\"BOE 2025 COMPLIANT POWER ANALYSIS\");\nconsole.log(\"=\".repeat(50));\n\nconst inputData = $input.first().json;\n\n// Get prices\nlet precios = inputData.precios_potencia || {};\nif (Object.keys(precios).length === 0) {\n    // Use BOE default prices for 3.0TD\n    precios = {\n        P1: 0.053858904,\n        P2: 0.028086712,\n        P3: 0.011678192,\n        P4: 0.010086438,\n        P5: 0.006378548,\n        P6: 0.003716137,\n    };\n}\n\nconsole.log(`Precios T√©rmino Potencia:`, precios);\nconsole.log(`Input source:`, inputData.is_manual_input ? 'MANUAL' : 'BILL');\n\n// Get SIPS data\nconst sipsRaw = inputData.sips_data || null;\n\nif (sipsRaw === null) {\n    console.log(\"ERROR: No SIPS data in input\");\n    return [{ \n        success: false, \n        error: 'No SIPS data available for this CUPS', \n        cups: inputData.cups,\n        analysis_results: [] \n    }];\n}\n\n// Parse SIPS data\nlet apiData;\nif (typeof sipsRaw === 'string') {\n    apiData = JSON.parse(sipsRaw);\n} else {\n    apiData = sipsRaw;\n}\n\nif (!apiData || !apiData.suministros) {\n    console.log(`ERROR: Invalid SIPS data structure`);\n    return [{ \n        success: false, \n        error: 'Invalid SIPS data structure', \n        cups: inputData.cups,\n        analysis_results: [] \n    }];\n}\n\n// Wrap and analyze\nconst wrappedData = { parsedData: apiData };\nconst results = analyzeCupsPower(wrappedData, precios);\n\nconsole.log(\"=\".repeat(50));\nconsole.log(`ANALYSIS COMPLETE: ${results.length} CUPS analyzed`);\nif (results.length > 0) {\n    console.log(`CUPS: ${results[0].CUPS}`);\n    console.log(`Tarifa: ${results[0].Tarifa}`);\n    console.log(`Coste Actual Anual: ${results[0].Coste_Actual_Anual?.toFixed(2)}‚Ç¨`);\n    console.log(`Coste Sugerido Anual: ${results[0].Coste_Total_Sugerido_Anual?.toFixed(2)}‚Ç¨`);\n    console.log(`Ahorro Anual: ${results[0].Ahorro_Anual?.toFixed(2)}‚Ç¨`);\n    console.log(`Penalizaciones Actuales: ${results[0].Total_Penalizaciones_Anual?.toFixed(2)}‚Ç¨`);\n    console.log(`Recomendaci√≥n: ${results[0].Recomendacion_General}`);\n}\nconsole.log(\"=\".repeat(50));\n\nreturn [{ \n    success: true, \n    cups: inputData.cups,\n    cups_analyzed: results.length, \n    is_manual_input: inputData.is_manual_input,\n    precios_utilizados: precios,\n    analysis_results: results \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        -772
      ],
      "id": "9dd5e160-e981-4992-82ee-abf52c06b4b5",
      "name": "Power Analysis Engine"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1984,
        -772
      ],
      "id": "response-node",
      "name": "Send Response"
    }
  ],
  "connections": {
    "Analisis de Potencia": {
      "main": [
        [
          {
            "node": "Has Bill?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Bill?": {
      "main": [
        [
          {
            "node": "Convert to PDF",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Manual Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to PDF": {
      "main": [
        [
          {
            "node": "Extract Bill Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Manual Input": {
      "main": [
        [
          {
            "node": "Prepare Power Analysis Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Bill Data",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Bill Data": {
      "main": [
        [
          {
            "node": "Normalize Bill Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Bill Extraction": {
      "main": [
        [
          {
            "node": "Prepare Power Analysis Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Power Analysis Data": {
      "main": [
        [
          {
            "node": "Fetch SIPS Data for Power",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch SIPS Data for Power": {
      "main": [
        [
          {
            "node": "Combine Data for Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Data for Analysis": {
      "main": [
        [
          {
            "node": "Power Analysis Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Power Analysis Engine": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "d9ea544fdadf26c0cb1af2a2170c8ad35272e6ce482d9566666c10e545e2572e"
  }
}
